# syntax=docker/dockerfile:1.5-labs

ARG ALPINE_VERSION=3.22

########################################
# Stage 1: Cross-compilation tool
########################################
FROM --platform=$BUILDPLATFORM tonistiigi/xx:1.2.1 AS xx

########################################
# Stage 2: Build ONLY LLD from LLVM source
# This is much faster and avoids building an incomplete Clang.
########################################
FROM alpine:${ALPINE_VERSION} AS lld-builder

RUN apk add --no-cache bash cmake ninja clang llvm-dev git

WORKDIR /lld-build
RUN git clone --depth=1 --branch=release/18.x https://github.com/llvm/llvm-project.git

WORKDIR /lld-build/llvm-project/llvm
RUN cmake -B build \
    -G Ninja \
    -DCMAKE_BUILD_TYPE=Release \
    -DCMAKE_INSTALL_PREFIX=/lld-install \
    -DLLVM_ENABLE_PROJECTS="lld"

RUN cmake --build build --target install

########################################
# Stage 3: Main Builder
# This stage uses the reliable system Clang and links it with our custom static LLD.
########################################
FROM alpine:${ALPINE_VERSION} AS builder

COPY --from=xx / /
SHELL ["bash", "-c"]

# Install host build dependencies
RUN apk add --no-cache bash cmake samurai clang g++ git

# Install TARGET dependencies into the sysroot
# CRITICAL: We do NOT install g++ into the sysroot to avoid stdlib conflicts.
RUN xx-apk add --no-cache \
    musl-dev \
    libc-dev \
    clang \
    libc++-static \
    libc++-dev \
    llvm-libunwind-static \
    zlib-static

# Copy our custom-built static LLD libraries into the sysroot for the compiler to find.
COPY --from=lld-builder /lld-install/lib/liblld*.a $(xx-info sysroot)/usr/lib/

# Create a simple, robust toolchain file.
RUN cat <<'EOT' > /usr/bin/xx-toolchain && chmod a+x /usr/bin/xx-toolchain
#!/bin/bash
set -e
SYSROOT=$(xx-info sysroot)
TARGET_TRIPLE=$(xx-clang --print-target-triple)
TOOLCHAIN_FILE="/etc/xx-toolchains/${TARGET_TRIPLE}.cmake"

if [ ! -f "$TOOLCHAIN_FILE" ]; then
    mkdir -p "$(dirname "$TOOLCHAIN_FILE")"
    cat <<EOF > "$TOOLCHAIN_FILE"
set(CMAKE_SYSTEM_NAME Linux)
set(CMAKE_SYSTEM_PROCESSOR "$(xx-info arch)")
set(CMAKE_SYSROOT "${SYSROOT}")

set(CMAKE_C_COMPILER "xx-clang")
set(CMAKE_CXX_COMPILER "xx-clang++")
set(CMAKE_AR "xx-llvm-ar")
set(CMAKE_RANLIB "xx-llvm-ranlib")

# Instruct the linker to use LLD and link everything statically.
set(CMAKE_EXE_LINKER_FLAGS "--sysroot=${SYSROOT} -stdlib=libc++ -fuse-ld=lld -static" CACHE STRING "")
EOF
fi
echo "$TOOLCHAIN_FILE"
EOT

# Configure WasmEdge
RUN --mount=type=bind,target=/src,source=. \
    cmake -S /src -B /build -G Ninja \
        -DCMAKE_BUILD_TYPE=MinSizeRel \
        -DCMAKE_POSITION_INDEPENDENT_CODE=ON \
        -DCMAKE_INSTALL_PREFIX="/install" \
        -DCMAKE_TOOLCHAIN_FILE="$(xx-toolchain)" \
        -DWASMEDGE_BUILD_PACKAGE="TGZ" \
        -DWASMEDGE_USE_LLVM=ON \
        -DWASMEDGE_BUILD_STATIC_LIB=ON \
        -DWASMEDGE_BUILD_TESTS=OFF \
        -DWASMEDGE_BUILD_SHARED_LIB=OFF \
        -DWASMEDGE_BUILD_TOOLS=OFF \
        -DWASMEDGE_BUILD_PLUGINS=OFF \
        -DWASMEDGE_BUILD_EXAMPLE=OFF \
        -DWASMEDGE_LINK_LLVM_STATIC=ON \
        -DWASMEDGE_LINK_TOOLS_STATIC=ON \
        -DWASMEDGE_DISABLE_LIBTINFO=ON

# Build WasmEdge
RUN --mount=type=bind,target=/src,source=. \
    cmake --build /build -- install package

# Rename the final package archive
RUN --mount=type=bind,target=/src,source=. <<EOT
    set -ex
    WASMEDGE_VERSION="$(cd /src && git describe --match '[0-9].[0-9]*' --tag)"
    ARCHIVE_TAG=${WASMEDGE_VERSION%%-*}-alpine${ALPINE_VERSION}_$(xx-info march)
    mv /build/WasmEdge-*-Linux.tar.gz /build/WasmEdge-${ARCHIVE_TAG}_static.tar.gz
EOT

########################################
# Stage 4 & 5: Final packaging stages
########################################
FROM scratch AS install
COPY --from=builder /install /

FROM scratch AS tar
COPY --from=builder /build/WasmEdge-*.tar.gz /
