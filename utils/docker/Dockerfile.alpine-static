# syntax=docker/dockerfile:1.5-labs

ARG ALPINE_VERSION=3.22

########################################
# Stage 1: Cross-compilation tool
########################################
FROM --platform=$BUILDPLATFORM tonistiigi/xx:1.2.1 AS xx

########################################
# Stage 2: Alpine Static Image with a Robust, Standard Toolchain
# NOTE: The custom lld-builder stage has been removed for stability.
########################################
FROM --platform=$BUILDPLATFORM alpine:${ALPINE_VERSION} AS alpine-static

COPY --from=xx /usr/bin/xx* /usr/bin/
RUN apk add --no-cache bash

SHELL ["bash", "-c"]

# Install all necessary build tools and the standard LLVM toolchain from Alpine's repository.
RUN apk add --no-cache \
    cmake \
    samurai \
    g++ \
    clang \
    llvm \
    lld \
    lld-dev \
    llvm-static \
    zlib-static \
    zlib-dev \
    git \
    musl-dev \
    libc-dev \
    libffi-dev

RUN mkdir -p $(xx-info sysroot)/usr/bin

# If cross-compiling, copy the necessary tools into the sysroot for the toolchain to find.
RUN if xx-info is-cross; then \
      cp /usr/bin/ld.lld $(xx-info sysroot)/usr/bin/; \
      cp /usr/bin/llvm-ar $(xx-info sysroot)/usr/bin/; \
      cp /usr/bin/llvm-ranlib $(xx-info sysroot)/usr/bin/; \
    fi

# Create a comprehensive, robust toolchain file generator
RUN cat <<'EOT' > /usr/bin/xx-toolchain && chmod +x /usr/bin/xx-toolchain
#!/bin/bash
set -e
SYSROOT=$(xx-info sysroot)
TARGET_TRIPLE=$(xx-clang --print-target-triple)
TOOLCHAIN_FILE="/etc/xx-toolchains/${TARGET_TRIPLE}.cmake"

# Only generate the file if it doesn't exist
if [ ! -f "$TOOLCHAIN_FILE" ]; then
    mkdir -p "$(dirname "$TOOLCHAIN_FILE")"
    echo "--- Generating CMake toolchain file for ${TARGET_TRIPLE} ---" >&2
    cat <<EOF > "$TOOLCHAIN_FILE"
# CMake Toolchain File for ${TARGET_TRIPLE}

set(CMAKE_SYSTEM_NAME Linux)
set(CMAKE_SYSTEM_PROCESSOR "$(xx-info arch)")
set(CMAKE_SYSROOT "${SYSROOT}")

set(CMAKE_C_COMPILER "$(which xx-clang)")
set(CMAKE_CXX_COMPILER "$(which xx-clang++)")
set(CMAKE_ASM_COMPILER "$(which xx-clang)")

# Use the C++ compiler driver as the linker. This is the most robust approach.
set(CMAKE_LINKER "$(which xx-clang++)")
set(CMAKE_AR "$(which xx-llvm-ar)")
set(CMAKE_RANLIB "$(which xx-llvm-ranlib)")

# Rely on the --sysroot flag to correctly handle standard include/library paths.
# Manually adding paths like -L\${SYSROOT}/usr/lib can be problematic.
set(CMAKE_CXX_FLAGS "--sysroot=${SYSROOT} -stdlib=libc++ -pthread" CACHE STRING "C++ compiler flags")
set(CMAKE_C_FLAGS "--sysroot=${SYSROOT} -pthread" CACHE STRING "C compiler flags")

# Linker flags. Explicitly link libunwind and libc++fs as required by static libc++.
# The compiler driver, respecting --sysroot, should find them in \${SYSROOT}/usr/lib.
set(COMMON_LINKER_FLAGS "--sysroot=${SYSROOT} -stdlib=libc++ -fuse-ld=lld -lunwind -lc++fs")
set(CMAKE_EXE_LINKER_FLAGS    "\${COMMON_LINKER_FLAGS}" CACHE STRING "Executable linker flags")
set(CMAKE_SHARED_LINKER_FLAGS "\${COMMON_LINKER_FLAGS}" CACHE STRING "Shared linker flags")
set(CMAKE_MODULE_LINKER_FLAGS "\${COMMON_LINKER_FLAGS}" CACHE STRING "Module linker flags")

set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)
set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)
set(CMAKE_FIND_ROOT_PATH_MODE_PACKAGE ONLY)
EOF
fi
echo "$TOOLCHAIN_FILE"
EOT

########################################
# Stage 3: wasmedge-build with the robust toolchain
########################################
FROM alpine-static AS wasmedge-build

ARG TARGETPLATFORM
ARG ALPINE_VERSION

WORKDIR /src
SHELL ["bash", "-c"]

# Install only host tools needed for the build.
RUN apk add --no-cache \
    curl \
    tar \
    git \
    ninja \
    bash \
    cmake

# Install a clean libc++ toolchain into the sysroot.
# Do NOT install g++, as it brings in a conflicting libstdc++ implementation.
RUN xx-apk add musl-dev libc-dev clang libc++-static libc++-dev llvm-libunwind-static

# Fake dsymutil for CMake sanity
RUN ln -sf /bin/true /usr/bin/dsymutil

# Sanity checks
RUN test -f "$(xx-info sysroot)/usr/include/stdlib.h" || (echo "stdlib.h not found in sysroot!" && false)
RUN test -f "$(xx-info sysroot)/usr/include/c++/v1/vector" || (echo "libc++ headers not found in sysroot!" && false)

# Trust the toolchain.
RUN --mount=type=bind,target=/src,source=. \
    cmake -S /src -B /build -G Ninja \
        -DCMAKE_BUILD_TYPE=MinSizeRel \
        -DCMAKE_POSITION_INDEPENDENT_CODE=ON \
        -DCMAKE_INSTALL_PREFIX="/install" \
        -DCMAKE_TOOLCHAIN_FILE="$(xx-toolchain)" \
        -DCMAKE_PREFIX_PATH="$(xx-info sysroot)/usr/lib/cmake/llvm" \
        -DWASMEDGE_BUILD_PACKAGE="TGZ" \
        -DWASMEDGE_USE_LLVM=ON \
        -DWASMEDGE_BUILD_STATIC_LIB=ON \
        -DWASMEDGE_BUILD_TESTS=OFF \
        -DWASMEDGE_BUILD_SHARED_LIB=OFF \
        -DWASMEDGE_BUILD_TOOLS=OFF \
        -DWASMEDGE_BUILD_PLUGINS=OFF \
        -DWASMEDGE_BUILD_EXAMPLE=OFF \
        -DWASMEDGE_LINK_LLVM_STATIC=ON \
        -DWASMEDGE_LINK_TOOLS_STATIC=ON \
        -DWASMEDGE_DISABLE_LIBTINFO=ON

# Build and install
RUN --mount=type=bind,target=/src,source=. \
    cmake --build /build -- install package

WORKDIR /src
CMD ["/bin/bash"]
